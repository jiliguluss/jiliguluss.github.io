<!DOCTYPE html><html lang="zh-cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>NoSQL 数据库 | 千里之行，始于足下</title><meta name="author" content="一瓢清浅"><meta name="copyright" content="一瓢清浅"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="NoSQL数据库以Redis（内存键值）、MongoDB（文档存储）、Elasticsearch（全文检索）为核心，通过分布式集群、数据分片及持久化机制支撑高并发大数据场景，需防范缓存穿透&#x2F;雪崩等典型问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="NoSQL 数据库">
<meta property="og:url" content="https://jiliguluss.github.io/2024/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/index.html">
<meta property="og:site_name" content="千里之行，始于足下">
<meta property="og:description" content="NoSQL数据库以Redis（内存键值）、MongoDB（文档存储）、Elasticsearch（全文检索）为核心，通过分布式集群、数据分片及持久化机制支撑高并发大数据场景，需防范缓存穿透&#x2F;雪崩等典型问题。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiliguluss.github.io/img/photo.jpg">
<meta property="article:published_time" content="2024-10-31T12:57:20.000Z">
<meta property="article:modified_time" content="2025-05-30T05:08:40.781Z">
<meta property="article:author" content="一瓢清浅">
<meta property="article:tag" content="软件工程">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="NoSQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiliguluss.github.io/img/photo.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "NoSQL 数据库",
  "url": "https://jiliguluss.github.io/2024/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/",
  "image": "https://jiliguluss.github.io/img/photo.jpg",
  "datePublished": "2024-10-31T12:57:20.000Z",
  "dateModified": "2025-05-30T05:08:40.781Z",
  "author": [
    {
      "@type": "Person",
      "name": "一瓢清浅",
      "url": "https://jiliguluss.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/photo.jpg"><link rel="canonical" href="https://jiliguluss.github.io/2024/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="lLxUyQ0yWzvjRV9T0cFyjdm4TmPy3qzD8tgziYKYf00"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'NoSQL 数据库',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/cover.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/photo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">18</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">千里之行，始于足下</span></a><a class="nav-page-title" href="/"><span class="site-name">NoSQL 数据库</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">NoSQL 数据库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-10-31T12:57:20.000Z" title="Created 2024-10-31 20:57:20">2024-10-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-05-30T05:08:40.781Z" title="Updated 2025-05-30 13:08:40">2025-05-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AF%E8%80%83/">软考</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AF%E8%80%83/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">系统架构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">5.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>16mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id data-flag-title><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h2 id="一、NoSQL 数据库简介"><a href="# 一、NoSQL 数据库简介" class="headerlink" title="一、NoSQL 数据库简介"></a>一、NoSQL 数据库简介 </h2><p>NoSQL（Not Only SQL）数据库是一种非关系型数据库，它不依赖于传统的关系型数据库管理系统（RDBMS）的表格模型。NoSQL 数据库通常是为了解决大规模数据集合的存储和检索问题而设计的，特别是在<strong> 大数据 </strong> 和<strong>高并发 </strong> 的应用场景中。</p>
<p>以下是 NoSQL 数据库的主要优势：</p>
<ol>
<li><strong>可扩展性</strong>：NoSQL 数据库可以轻松地扩展到处理海量数据，而无需昂贵的硬件或复杂的配置。</li>
<li><strong>高并发性</strong>：NoSQL 数据库可以处理大量并发请求，使其非常适合处理实时数据和高流量应用程序。</li>
<li><strong>灵活性</strong>：NoSQL 数据库提供灵活的数据模型，可以轻松适应不断变化的数据需求，而无需更改架构。</li>
<li><strong>高可用性</strong>：NoSQL 数据库通常具有高可用性，并提供冗余和故障转移功能，以确保数据始终可用。</li>
</ol>
<p>同时 NoSQL 数据库也存在一些不足：</p>
<ol>
<li>数据一致性：NoSQL 数据库为了提高系统的可用性和分区容忍性，牺牲了一致性，采用最终一致性模型（BASE），这与关系型数据库的 ACID 属性（原子性、一致性、隔离性、持久性）不同。这意味着在某些情况下，NoSQL 数据库可能无法保证所有节点看到的数据是一致的。</li>
<li>事务处理：NoSQL 数据库通常不支持传统的 ACID 事务，使得跨多个操作维持数据的完整性比较困难，即难以支持复杂的事务操作。</li>
<li>查询功能：NoSQL 数据库的查询功能不如关系型数据库强大，这可能会限制复杂查询和数据分析的效率和灵活性。</li>
<li>数据建模：NoSQL 数据库的非关系数据模型需要不同的建模技术，如文档型、键值型、列存储和图形数据库等。虽然提供了灵活性，但需要较高的学习成本。</li>
</ol>
<h2 id="二、NoSQL 数据库类型"><a href="# 二、NoSQL 数据库类型" class="headerlink" title="二、NoSQL 数据库类型"></a>二、NoSQL 数据库类型</h2><div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>场景</th>
<th>结构</th>
<th>产品</th>
</tr>
</thead>
<tbody>
<tr>
<td>键值数据库</td>
<td>内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等</td>
<td>Key-Value 的键值对，通常用 hash table 来实现</td>
<td>Redis，Memcached</td>
</tr>
<tr>
<td>列存储数据库</td>
<td>分布式的文件系统</td>
<td>以列簇式存储，将同一列数据存在一起</td>
<td>Cassandra，HBase</td>
</tr>
<tr>
<td>文档型数据库</td>
<td>Web 应用</td>
<td>以 JSON、BSON、XML 等格式记录的文档</td>
<td>MongoDB，ElasticSearch</td>
</tr>
<tr>
<td>图形数据库</td>
<td>社交网络，推荐系统，知识图谱等</td>
<td>图结构</td>
<td>Neo4J</td>
</tr>
</tbody>
</table>
</div>
<h2 id="三、常见 NoSQL 数据库"><a href="# 三、常见 NoSQL 数据库" class="headerlink" title="三、常见 NoSQL 数据库"></a>三、常见 NoSQL 数据库</h2><h3 id="一 -Redis"><a href="# 一 -Redis" class="headerlink" title="(一) Redis"></a>(一) Redis</h3><p>Redis（Remote Dictionary Server）是一个开源的高性能键值对（key-value）数据库。Redis 的数据保存在内存中，是一款内存数据库，读写速度非常快，通常用作数据库、缓存和消息传递系统。</p>
<h4 id="1- 数据结构与操作指令"><a href="#1- 数据结构与操作指令" class="headerlink" title="1. 数据结构与操作指令"></a>1. 数据结构与操作指令</h4><p>Redis 支持 8 种数据结构，分别用于不同的业务场景：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据结构</th>
<th>说明</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串（String）</td>
<td>文本数据，二进制数据</td>
<td>- 缓存功能：存储对象、配置信息等。<br>- 计数器：实现简单的计数功能。<br>- 消息队列：存储消息内容。</td>
</tr>
<tr>
<td>列表（List）</td>
<td>一个有序集合，支持在两端推入和弹出元素</td>
<td>- 消息队列：实现先进先出（FIFO）的消息队列。<br>- 保持时序：展示最新文章、最新动态。</td>
</tr>
<tr>
<td>集合（Set）</td>
<td>无序集合，自动去重</td>
<td>- 标签系统：存储用户标签。<br>- 交并差运算：找出共同好友。</td>
</tr>
<tr>
<td>有序集合（ZSet）</td>
<td>与 Set 类似，但每个元素关联了一个分数，可以进行排序</td>
<td>- 排行榜：根据分数排序。<br>- 范围查询：实现范围查询功能。</td>
</tr>
<tr>
<td>哈希表（Hash）</td>
<td>键值对集合，可以存储对象</td>
<td>- 对象信息：存储用户信息、订单信息等。<br>- 缓存记录：存储复杂数据结构。</td>
</tr>
<tr>
<td>位图（Bitmap）</td>
<td>使用 bit 位来存储信息，适合做标记或计数</td>
<td>- 记录状态：标记用户是否在线。<br>- 签到功能：标记用户签到状态。</td>
</tr>
<tr>
<td>基数统计（HyperLogLog）</td>
<td>用于基数统计，可以估算集合中不同元素的数量</td>
<td>- 大数据计数：统计网站 UV。</td>
</tr>
<tr>
<td>地理空间索引（Geospatial）</td>
<td>存储地理位置信息，可以进行地理位置查询</td>
<td>- 就近推荐：根据地理位置查找附近的用户或服务。<br>- 地图服务：存储和查询地理位置信息。</td>
</tr>
</tbody>
</table>
</div>
<p>Redis 常见的操作指令如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串（String）</td>
<td>SET key value：设置字符串的值。<br>GET key：获取字符串的值。<br>INCR key：将字符串（整数值）增加 1。<br>DECR key：将字符串（整数值）减少 1。<br>APPEND key value：向字符串追加值。</td>
</tr>
<tr>
<td>列表（Lists）</td>
<td>LPUSH key value：在列表头部插入元素。<br>RPUSH key value：在列表尾部插入元素。 <br> LPOP key：在列表头部弹出元素。<br>RPOP key：在列表尾部弹出元素。<br>LRANGE key start stop：获取列表中指定范围的元素。</td>
</tr>
<tr>
<td>集合（Sets）</td>
<td>SADD key member [member …]：向集合添加一个或多个成员。<br>SREM key member [member …]：从集合中删除一个或多个成员。<br>SPOP key：从集合中随机移除并返回一个成员。<br>SCARD key：获取集合的成员数。</td>
</tr>
<tr>
<td>有序集合（ZSet）</td>
<td>ZADD key score member [score member …]：向有序集合添加一个或多个成员，每个成员关联一个分数。<br>ZREM key member [member …]：从有序集合中删除一个或多个成员。<br>ZRANGE key start stop [WITHSCORES]：获取有序集合中指定分数范围的成员。</td>
</tr>
<tr>
<td>哈希表（Hash）</td>
<td>HSET key field value：在哈希表中设置字段的值。<br> HGET key field：从哈希表中获取字段的值。<br>HGETALL key：获取哈希表中所有的字段和值。</td>
</tr>
<tr>
<td>位图（Bitmap）</td>
<td>SETBIT key offset value：在字符串对象中设置位的值。<br>GETBIT key offset：获取字符串对象中位的值。</td>
</tr>
<tr>
<td>基数统计（HyperLogLog）</td>
<td>PFADD key element [element …]：向 HyperLogLog 中添加元素。<br>PFCOUNT key：返回 HyperLogLog 的近似基数。</td>
</tr>
<tr>
<td>地理空间索引（Geospatial）</td>
<td>GEOADD key longitude latitude member [longitude latitude member …]：将地理空间位置的元素添加到键中。<br>GEODIST key member1 member2：返回两个地理空间位置之间的距离。<br>GEORADIUS key longitude latitude radius m&#124;km [WITHCOORD] [WITHDIST] [WITHHASH]：返回位于给定坐标周围指定半径内的所有元素。</td>
</tr>
<tr>
<td>键管理</td>
<td>KEYS pattern：查找所有匹配给定模式的键。<br>DEL key [key …]：删除一个或多个键。<br>EXPIRE key seconds：设置键的生存时间。</td>
</tr>
<tr>
<td>事务</td>
<td>MULTI：开始一个事务块。<br>EXEC：执行事务块中的所有命令。<br>WATCH key [key …]：监视一个或多个键，如果在执行事务期间这些键被修改，则事务将失败。</td>
</tr>
<tr>
<td>持久化</td>
<td>SAVE：将数据同步到磁盘。<br>BGSAVE：在后台异步保存数据到磁盘。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2- 持久化机制"><a href="#2- 持久化机制" class="headerlink" title="2. 持久化机制"></a>2. 持久化机制</h4><p>Redis 是内存数据库，在默认情况下数据是易失的，如果服务器宕机，内存中的数据会丢失。为了避免这种情况，Redis 提供了持久化机制来确保数据的持久存储。Redis 有两种持久化机制：</p>
<ol>
<li><p>RDB（Redis DataBase）<br>RDB 持久化是默认的持久化方式，它会在指定的时间间隔内，将内存中的数据以快照的形式写入磁盘。这种方式可以快速恢复数据，但如果发生故障，可能造成数据丢失。</p>
</li>
<li><p>AOF（Append-Only File）<br>AOF 持久化是将 Redis 执行的每次写命令都追加到日志文件中，可以做到秒级数据持久化。当 Redis 重启时，会重新执行这些命令来恢复数据，恢复速度较慢。</p>
</li>
</ol>
<p>RDB 适合大规模数据备份和恢复，而 AOF 适合需要高数据安全性的场景。</p>
<p>Redis 4.0 引入了混合持久化，这种模式结合了 RDB 和 AOF 的优点。在这种模式下，AOF 文件的开始部分是 RDB 数据的二进制 dump，紧接着是追加的 AOF 日志。这样既可以快速还原数据，又能保留足够的操作日志来保证数据的完整性。</p>
<h4 id="3-Redis 集群"><a href="#3-Redis 集群" class="headerlink" title="3. Redis 集群"></a>3. Redis 集群</h4><p>Redis 集群是通过将多个 Redis 节点连接在一起实现高可用性、数据分片和负载均衡的技术。Redis 集群的优势在于高可用性、负载均衡、容灾恢复、数据分片和易于扩展。</p>
<p>Redis 集群有三种组织模式：</p>
<ol>
<li>主从复制模式 <br> 通过将一个 Redis 节点（主节点）的数据复制到其他节点（从节点）实现数据冗余和备份。主节点负责写操作，从节点负责读操作，实现读写分离。</li>
</ol>
<ul>
<li>优点：配置简单；实现数据冗余和读写分离</li>
<li>缺点：无法自动故障转移；首单节点内存限制</li>
<li>场景：数据备份、读写分离和在线升级的场景</li>
</ul>
<img src="/2024/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F.jpg" class title="redis 主从复制模式 ">
<ol>
<li>哨兵模式 <br> 在主从模式的基础上添加哨兵节点，实现自动故障转移。哨兵节点监控主从节点，当主节点故障时自动选举新的主节点。</li>
</ol>
<ul>
<li>优点：实现数据冗余和读写分离；自动故障转移，提高可用性</li>
<li>缺点：配置和管理相对复杂</li>
<li>场景：对可用性要求较高的场景</li>
</ul>
<img src="/2024/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.jpg" class title="redis 哨兵模式 ">
<ol>
<li>Cluster 模式 <br> 通过数据分片和分布式存储，实现负载均衡和大规模数据存储。采用去中心化架构，减少单点故障风险。数据被划分为 16384 个哈希槽（slots），每个节点负责一部分槽位。</li>
</ol>
<ul>
<li>优点：实现大规模数据存储、负载均衡和自动故障转移</li>
<li>缺点：配置和管理比较复杂，复杂操作受限</li>
<li>场景：大规模数据存储和高性能要求的场景</li>
</ul>
<img src="/2024/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.png" class title="redis 集群模式 ">
<h4 id="4-Redis 与数据库同步"><a href="#4-Redis 与数据库同步" class="headerlink" title="4. Redis 与数据库同步"></a>4. Redis 与数据库同步 </h4><p> 实际系统中，Redis 经常与数据库配合使用，通过缓存、消息队列、实时分析和分布式锁等功能，提升系统的性能和可扩展性。为了维护缓存与数据库的数据一致性，需要将 Redis 与数据库进行同步。</p>
<p>Redis 与数据库的同步机制有多种，常见的是 <strong> 缓存旁路策略</strong>。</p>
<ul>
<li><strong>读数据 </strong> 时，先查询缓存，如果缓存中存在所需的数据，则直接返回。如果缓存中没有，则查询数据库，获取数据并写入缓存。</li>
<li><strong>写数据 </strong> 时，先更新数据库，然后直接删除缓存中对应的数据，下次读取时会自动从数据库中加载最新数据到缓存。如果更新数据库成功，删除缓存失败，可使用缓存更新重试机制。</li>
</ul>
<h4 id="5- 过期删除与内存淘汰"><a href="#5- 过期删除与内存淘汰" class="headerlink" title="5. 过期删除与内存淘汰"></a>5. 过期删除与内存淘汰 </h4><p> 过期删除和内存淘汰都是将一些数据从 Redis 中删掉，区别在于：</p>
<ul>
<li><strong>过期删除 </strong>：从<strong> 时间角度 </strong> 考虑，当数据超过了设置的生命周期时，需要把过期数据从内存中删掉。常用的删除策略有：<ul>
<li><strong>定时删除</strong>：每个设置过期时间的键都需要创建一个定时器，到过期时间就会立即清除。对内存友好，对 CPU 不友好（会占用大量的 CPU 资源去清理）。</li>
<li><strong>惰性删除</strong>：只有当访问一个 key 时，才会判断该 key 是否已过期，过期则清除。对 CPU 友好，对内存不友好（可能存在大量过期 key 没有被删除）。</li>
<li><strong>定期删除</strong>：每隔一段时间会描一批 key，并清除其中已过期的 key。通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响，达到 CPU 与内存平衡的效率。</li>
</ul>
</li>
<li><strong>内存淘汰 </strong>：从<strong> 空间角度 </strong> 考虑，当 Redis 存储容量超过了内存限制，需要从内存中淘汰一些老数据，才能存入新数据。常用的淘汰策略有：<ul>
<li>noeviction（默认策略）：不淘汰任何数据，但是内存满时不允许写入新数据。保证数据完整性，但影响可用性。</li>
<li>volatile-lru（最近最少使用）：从已设置过期时间的键中淘汰最近最少使用的数据，适合缓存场景。</li>
<li>allkeys-lru（全局最近最少使用）：从所有键中淘汰最近最少使用的数据，适合缓存场景。</li>
<li>volatile-random（随机淘汰）：从已设置过期时间的键中随机淘汰。</li>
<li>allkeys-random（全局随机淘汰）：从所有键中随机淘汰。</li>
<li>volatile-lru（最小 TTL 优先）：从已设置过期时间的键中淘汰剩余生存时间最短的，适合缓存即将过期的数据。</li>
</ul>
</li>
</ul>
<h4 id="6- 缓存常见问题"><a href="#6- 缓存常见问题" class="headerlink" title="6. 缓存常见问题"></a>6. 缓存常见问题</h4><div class="table-container">
<table>
<thead>
<tr>
<th>问题</th>
<th>现象</th>
<th>应对</th>
</tr>
</thead>
<tbody>
<tr>
<td>缓存穿透</td>
<td>查询一个在缓存和数据库中都不存在的数据，由于在缓存中找不到，每次请求都要到数据库查询，然后返回空结果。如果这种请求很多，会对数据库造成很大压力。</td>
<td>- 缓存无效 key：将查询结果为空的操作也进行缓存，但设置一个较短的过期时间。<br>- 布隆过滤器：在查询前使用布隆过滤器判断数据是否存在，如果不存在则直接返回，如果存在再进行数据库查询。 <br>- 查询校验：校验查询参数，非法查询直接返回异常。</td>
</tr>
<tr>
<td>缓存击穿</td>
<td>某个热点缓存数据在某个时间点过期，而此时如果有大量请求访问这个数据，会导致数据库在同一时间点被大量请求击中，造成数据库压力突增。</td>
<td>- 延长失效：设置热点数据永不过期或者过期时间很长。<br>- 互斥锁：请求数据写入缓存前，先获取互斥锁，保证只有一个请求会落到数据库，数据加载完后再释放锁。 <br> - 缓存预热：提前加载热点数据到缓存中。</td>
</tr>
<tr>
<td>缓存雪崩</td>
<td>缓存服务器宕机或大量缓存在同一时间过期，导致大量请求直接访问数据库，造成数据库压力过大，甚至宕机。</td>
<td>- Redis 集群：避免单机故障。<br>- 接口限流：避免同时发起大量请求。 <br>- 多级缓存：使用本地缓存 +Redis 缓存，降低单点缓存失效的影响。 <br>- 随机过期：给缓存数据设置随机过期时间，避免大量缓存同时过期。</td>
</tr>
<tr>
<td>热 key 问题</td>
<td>某些 key 的请求量特别大，导致这些 key 成为热点数据，可能会因为访问量过大而拖垮整个缓存系统。</td>
<td>- 热点数据分散：将热点数据分散到不同的缓存节点，避免单点过热。<br>- 读写分离：对热点数据进行读写分离，通过多个副本分担读请求。</td>
</tr>
<tr>
<td>大 key 问题</td>
<td>某些 key 存储了过大的数据，这些数据在存储和网络传输上都会带来问题，影响缓存的性能。</td>
<td>- 数据拆分：将大 key 数据拆分成多个小 key 数据，在集群上均衡存储。 <br>- 及时清理： 定时清理过期的大 key 数据。<br>- 合理存储：将不适用 Redis 能力的数据存至其它存储，并在 Redis 中删除。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="二 -MongoDB"><a href="# 二 -MongoDB" class="headerlink" title="(二) MongoDB"></a>(二) MongoDB</h3><p>MongoDB 是一个流行的文档型 NoSQL 数据库，具有高性能、高可用性和可扩展性。MongoDB 存储 BSON（二进制 JSON）格式的数据，它是一种类 JSON 的格式，除了字符串、数值、日期、数组等数据结构，还能存储地理数据、对象、二进制数据等复杂的数据结构。</p>
<h4 id="1- 数据类型"><a href="#1- 数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h4><p>MongDB 中的记录是一个类似 JSON 结构的 BSON 文档，二者区别如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>对比项</th>
<th>BSON</th>
<th>JSON</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据格式</td>
<td>二进制</td>
<td>文本</td>
</tr>
<tr>
<td>数据类型</td>
<td>支持日期、整形、浮点性、字符串、二进制等多种原生数据类型</td>
<td>支持字符串、数值、数组等类型，相对有限</td>
</tr>
<tr>
<td>运行效率</td>
<td>存储紧凑，速度快；压缩算法效果有限，文件体积大</td>
<td>存储相对不进奏，速度慢；压缩算法效果较好，文件体积小</td>
</tr>
<tr>
<td>可读性</td>
<td>需要使用专门的工具</td>
<td>人眼可读</td>
</tr>
<tr>
<td>使用场景</td>
<td>对读写速度要求高，数据结构复杂，且需要外数据类型支持的操作场景</td>
<td>互联网数据传输、开发调试操作等操作场景</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-MongoDB 集群"><a href="#2-MongoDB 集群" class="headerlink" title="2. MongoDB 集群"></a>2. MongoDB 集群</h4><p>MongoDB 集群主要有两种模式：副本集和分片。</p>
<h5 id="1- 副本集（Replica-Set）"><a href="#1- 副本集（Replica-Set）" class="headerlink" title="(1) 副本集（Replica Set）"></a>(1) 副本集（Replica Set）</h5><p>副本集是 MongoDB 中用于 <strong> 实现数据冗余、高可用性和读负载均衡 </strong> 的主要方式。</p>
<p>副本集是一组 MongoDB 进程实例的集合，其中的数据相互复制，并自动进行故障转移。副本集包含一个主节点（Primary）和多个从节点（Secondary），主从节点通过 oplog 来同步数据。</p>
<p>主节点负责处理所有写操作，并将操作记录到 oplog，从节点读取 oplog 并应用，实现数据同步。副本集内所有主从节点都存储相同的数据，保证了数据的一致性。</p>
<p>当主节点不可用时，从节点通过竞选机制，从中选取一个主节点。当之前的主节点恢复使用时，作为从节点重新加入副本集。MongoDB 副本集类似于 Redis 的哨兵模式，使得 MongoDB 可以实现自动故障转移，提升了可用性。</p>
<img src="/2024/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb%E5%89%AF%E6%9C%AC%E9%9B%86.png" class title="mongodb 副本集 ">
<h5 id="2- 分片（Sharding）"><a href="#2- 分片（Sharding）" class="headerlink" title="(2) 分片（Sharding）"></a>(2) 分片（Sharding）</h5><p>分片是 MongoDB 用于 <strong> 存储海量数据和高并发读写 </strong> 的架构模式。</p>
<p>分片是指数据划分为多个分片（shards），每个分片可以是一个副本集，数据根据分片键（shard key）分布在不同的分片上。每个分片存储在不同的机器节点上，通过水平扩展，实现大规模数据的存储和处理。</p>
<p>分片策略有两种：</p>
<ul>
<li><p>哈希分片：通过计算分片键的字段值的哈希值来分布数据</p>
<ul>
<li>优点：数据分布均衡</li>
<li>缺点：处理基于范围的查询比较低效</li>
<li>场景：随机的数据访问，无法确定特定的数据范围</li>
</ul>
<img src="/2024/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb%E5%93%88%E5%B8%8C%E5%88%86%E7%89%87.png" class title="mongodb 哈希分片 ">
</li>
<li><p>范围分片：根据分片键的字段值范围将数据分布到不同的分片上</p>
<ul>
<li>优点：容易数据倾斜</li>
<li>缺点：范围查询效率高，数据局部性好，有利于某些分析操作</li>
<li>场景：数据按某个属性连续增长，需要按区间进行查询</li>
</ul>
<img src="/2024/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb%E8%8C%83%E5%9B%B4%E5%88%86%E7%89%87.png" class title="mongodb 范围分片 ">
</li>
</ul>
<h3 id="三 -Elasticsearch"><a href="# 三 -Elasticsearch" class="headerlink" title="(三) Elasticsearch"></a>(三) Elasticsearch</h3><p>Elasticsearch（简称 ES）是一个开源的、分布式的、高度可扩展的全文搜索引擎，它能快速（近实时）存储、搜索和分析大量数据（包括文本、数字、地理空间、结构化和非结构化数据等所有类型），广泛用于日志统计、系统监控、地理位置查询等场景。</p>
<h4 id="1- 全文检索"><a href="#1- 全文检索" class="headerlink" title="1. 全文检索"></a>1. 全文检索</h4><p>‌全文检索‌是一种针对非结构化文本数据的搜索技术，通过建立索引快速定位相关内容。其核心在于将文本中的每个词或字符建立索引，并允许用户以自然语言进行查询。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>技术点</th>
<th>原理</th>
<th>实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>分析器</td>
<td>用字符过滤器对文本进行预处理；用分词器将文本分解为词元；用标记过滤器把词元处理成易于搜索的形式</td>
<td>使用分词组件，选择不同配置（standard/whitespace/keyword 等）</td>
</tr>
<tr>
<td>词干分析</td>
<td>将词元还原成词干形式，提高搜索召回率</td>
<td>基于规则（Porter 算法）或词典（Snowball 框架）实现</td>
</tr>
<tr>
<td>停用词过滤</td>
<td>移除高频但无实际意义的词，减少索引冗余和噪声干扰</td>
<td>使用停用词列表</td>
</tr>
<tr>
<td>同义词处理</td>
<td>扩展查询词的同义词，提升准确率和召回率</td>
<td>使用同义词映射文件</td>
</tr>
<tr>
<td>相关性排名</td>
<td>根据词频（TF）、逆文档频率（IDF）、位置权重等计算文档与查询的匹配度，结合语义相似度排序</td>
<td>使用 TF-IDF 算法、BERT 语义模型等计算相关性排序</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2- 倒排索引"><a href="#2- 倒排索引" class="headerlink" title="2. 倒排索引"></a>2. 倒排索引</h4><p>ES 分片数据中存储的是倒排索引（Inverted Index）。倒排索引是一种索引数据结构，它将文档中出现的关键词映射到包含这些关键词的所有文档的列表上。</p>
<p>换句话说，倒排索引是一个从“词 -&gt; 文档”的映射关系，这种结构特别适合用于全文检索，它能够快速地找到包含指定关键词的所有文档，而不用扫描整个文档集合。</p>
<img src="/2024/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/ES%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.png" class title="ES 倒排索引 ">
<h4 id="3-ES 集群"><a href="#3-ES 集群" class="headerlink" title="3. ES 集群"></a>3. ES 集群</h4><p>ES 天生就是分布式的，主要采用分片模式。分片的目的是分割巨大的索引，将数据分散到集群内各处。分片分为主分片和副本分片，通常一个主分片有多个副本分片。主分片负责处理处理请求和存储数据，副本分片只负责存储数据，是主分片的数据备份。</p>
<img src="/2024/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/ES%E5%88%86%E7%89%87%E6%A8%A1%E5%BC%8F.png" class title="ES 分片 ">
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/NoSQL/">NoSQL</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8A%9F%E8%83%BD/" title="数据库的控制功能"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">数据库的控制功能</div></div><div class="info-2"><div class="info-item-1">数据库控制功能涵盖事务管理（ACID特性）、并发控制（锁机制与隔离级别）、性能优化（索引/读写分离/分区分片）及备份恢复机制，保障数据一致性与系统可靠性。</div></div></div></a><a class="pagination-related" href="/2024/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/" title="SOA 架构与微服务架构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">SOA 架构与微服务架构</div></div><div class="info-2"><div class="info-item-1">SOA依赖ESB集成粗粒度服务，采用标准化协议（如SOAP）和共享数据库，适用于企业级系统整合；微服务以细粒度自治服务为核心，各服务独立部署并拥有专属数据库，通过API网关和轻量通信（如REST）实现去中心化管理。</div></div></div></a></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/photo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info-name">一瓢清浅</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/jiliguluss"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">个人技术博客，涉及软件开发、安全测试、AI算法等领域。不求精深，但当涉猎，有所闻耳。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81NoSQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B"><span class="toc-text">一、NoSQL 数据库简介 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81NoSQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B"><span class="toc-text">二、NoSQL 数据库类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B8%B8%E8%A7%81%20NoSQL%20%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">三、常见 NoSQL 数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%20-Redis"><span class="toc-text">(一) Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-text">1. 数据结构与操作指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%20%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-text">2. 持久化机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Redis%20%E9%9B%86%E7%BE%A4"><span class="toc-text">3. Redis 集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Redis%20%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8C%E6%AD%A5"><span class="toc-text">4. Redis 与数据库同步 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%20%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0"><span class="toc-text">5. 过期删除与内存淘汰 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%20%E7%BC%93%E5%AD%98%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">6. 缓存常见问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%20-MongoDB"><span class="toc-text">(二) MongoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. 数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-MongoDB%20%E9%9B%86%E7%BE%A4"><span class="toc-text">2. MongoDB 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%20%E5%89%AF%E6%9C%AC%E9%9B%86%EF%BC%88Replica-Set%EF%BC%89"><span class="toc-text">(1) 副本集（Replica Set）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%20%E5%88%86%E7%89%87%EF%BC%88Sharding%EF%BC%89"><span class="toc-text">(2) 分片（Sharding）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%20-Elasticsearch"><span class="toc-text">(三) Elasticsearch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%20%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2"><span class="toc-text">1. 全文检索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%20%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="toc-text">2. 倒排索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ES%20%E9%9B%86%E7%BE%A4"><span class="toc-text">3. ES 集群</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/%E5%A4%9A%E8%87%82%E8%80%81%E8%99%8E%E6%9C%BA/" title="多臂老虎机">多臂老虎机</a><time datetime="2025-05-28T00:57:38.000Z" title="Created 2025-05-28 08:57:38">2025-05-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/" title="进程间通信机制">进程间通信机制</a><time datetime="2025-05-26T06:24:56.000Z" title="Created 2025-05-26 14:24:56">2025-05-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/Web%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/" title="Web 应用架构">Web 应用架构</a><time datetime="2025-05-21T06:52:47.000Z" title="Created 2025-05-21 14:52:47">2025-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/%E3%80%8A%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8%E3%80%81%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《股票投资入门、进阶与实战》笔记">《股票投资入门、进阶与实战》笔记</a><time datetime="2025-02-24T04:50:18.000Z" title="Created 2025-02-24 12:50:18">2025-02-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/%E3%80%8A%E6%8A%95%E8%B5%84%E4%B8%AD%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《投资中最简单的事》笔记">《投资中最简单的事》笔记</a><time datetime="2025-01-20T01:05:49.000Z" title="Created 2025-01-20 09:05:49">2025-01-20</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By 一瓢清浅</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23li8lUWNadcQIsjjS',
      clientSecret: 'a3a90b60503b4f298c2a09778e26da53ae01f9cd',
      repo: 'comment',
      owner: 'jiliguluss',
      admin: ['jiliguluss'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'e4e212c5ac53f66427a41ef8b32ac559'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>