<!DOCTYPE html><html lang="zh-cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Docker 必知必会 | 千里之行，始于足下</title><meta name="author" content="一瓢清浅"><meta name="copyright" content="一瓢清浅"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Docker是一种基于Linux命名空间和控制组的操作系统级虚拟化技术，通过镜像分层与联合文件系统实现轻量级应用封装，提供便捷的打包、分发和运行环境，显著提升开发部署效率。">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker 必知必会">
<meta property="og:url" content="https://jiliguluss.github.io/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/index.html">
<meta property="og:site_name" content="千里之行，始于足下">
<meta property="og:description" content="Docker是一种基于Linux命名空间和控制组的操作系统级虚拟化技术，通过镜像分层与联合文件系统实现轻量级应用封装，提供便捷的打包、分发和运行环境，显著提升开发部署效率。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiliguluss.github.io/img/photo.jpg">
<meta property="article:published_time" content="2023-07-08T08:10:21.000Z">
<meta property="article:modified_time" content="2025-05-30T05:12:50.471Z">
<meta property="article:author" content="一瓢清浅">
<meta property="article:tag" content="Docker">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiliguluss.github.io/img/photo.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker 必知必会",
  "url": "https://jiliguluss.github.io/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/",
  "image": "https://jiliguluss.github.io/img/photo.jpg",
  "datePublished": "2023-07-08T08:10:21.000Z",
  "dateModified": "2025-05-30T05:12:50.471Z",
  "author": [
    {
      "@type": "Person",
      "name": "一瓢清浅",
      "url": "https://jiliguluss.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/photo.jpg"><link rel="canonical" href="https://jiliguluss.github.io/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker 必知必会',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/cover.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/photo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">18</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">千里之行，始于足下</span></a><a class="nav-page-title" href="/"><span class="site-name">Docker 必知必会</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Docker 必知必会</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-07-08T08:10:21.000Z" title="Created 2023-07-08 16:10:21">2023-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-05-30T05:12:50.471Z" title="Updated 2025-05-30 13:12:50">2025-05-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BF%90%E7%BB%B4/Docker/">Docker</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id data-flag-title><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h2 id="一、基本概念"><a href="# 一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>Docker 是一种轻量级的虚拟化技术，可以让开发者非常便捷地实现应用程序的打包、移植、启动等操作，在软件开发、交付和部署中，有非常广泛的应用。</p>
<p>Docker 容器与传统虚拟机的架构对比如下：</p>
<img src="/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/vm-vs-docker.jpg" class title="docker 子目录 ">
<p>传统 VM 使用 Hypervisor 通过对物理主机的硬件资源进行协调和管理，为每个 GuestOS 分配独立的资源，让每个 GuestOS 成为一个虚拟主机，不同的 GuestOS 中的应用程序互不影响。Docker 容器直接运行在物理主机的 HostOS 上，共用物理主机的硬件资源，Container Engine 负责实现容器之间的资源隔离，让每个容器的应用独立地运行。</p>
<p>可以看出，容器比虚拟机少了一层 GuestOS，容器占用资源更少，启动更快，但隔离程度不如虚拟机。容器和虚拟机简要对比如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>维度</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>隔离级别</td>
<td>进程级</td>
<td>操作系统级</td>
</tr>
<tr>
<td>镜像大小</td>
<td>K-M 级</td>
<td>M-G 级</td>
</tr>
<tr>
<td>启动时间</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>性能表现</td>
<td>接近原生</td>
<td>有损耗</td>
</tr>
<tr>
<td>移植性</td>
<td>轻量</td>
<td>重量</td>
</tr>
<tr>
<td>隔离性</td>
<td>弱</td>
<td>强</td>
</tr>
<tr>
<td>安全性</td>
<td>弱</td>
<td>强</td>
</tr>
</tbody>
</table>
</div>
<p>Docker 中有三个常见的名词：镜像、容器和仓库。这里先简单介绍下概念，知道是什么就行，后面再详细说明。</p>
<h3 id="（一）镜像（Image）"><a href="#（一）镜像（Image）" class="headerlink" title="（一）镜像（Image）"></a>（一）镜像（Image）</h3><p>镜像是一个特殊的文件系统，提供容器运行时所需的环境和配置，例如程序、库、资源、配置等文件，以及环境变量、匿名卷、用户等配置参数。镜像是静态的，不包含任何动态数据，在镜像构建之后，其内容不会发生改变。</p>
<h3 id="（二）容器（Container）"><a href="#（二）容器（Container）" class="headerlink" title="（二）容器（Container）"></a>（二）容器（Container）</h3><p>容器和镜像的关系，类似于面向对象编程中对象和类的关系，容器是运行镜像后得到的实例，运行镜像就相当于类的实例化，多次运行镜像，可以得到多个容器。容器是动态的，可以对容器进行创建、删除、启动、停止、暂停等操作。</p>
<p>容器实质上是运行在宿主机上的进程，Docker 是用特殊的技术将容器与宿主机上的其他进程隔离开来，使得容器内的应用看起来是运行在一个独立的环境中。</p>
<h3 id="（三）仓库（Repository）"><a href="#（三）仓库（Repository）" class="headerlink" title="（三）仓库（Repository）"></a>（三）仓库（Repository）</h3><p>仓库类似 github，对镜像进行存储和分发。在任一宿主机上，都可以从仓库拉取指定镜像，也可以把自己打包好的镜像上传到仓库，供他人访问。默认的是官方仓库 Docker Hub，拥有众多官方镜像，国内访问需要配加速器，如阿里云的镜像仓。也可以自行搭建本地私有镜像仓。</p>
<h2 id="二、基础原理"><a href="# 二、基础原理" class="headerlink" title="二、基础原理"></a>二、基础原理 </h2><p> 前面提到，容器是宿主机用特殊机制隔离出来的进程。为了实现容器进程的互不干扰，这个机制需要解决两个基本问题：</p>
<ol>
<li>容器内屏蔽容器外的情况，使用 Linux 的 Namespace 机制</li>
<li>容器拥有独立的资源，使用 Linux 的 Cgroups 机制</li>
</ol>
<h3 id="（一）Namespace"><a href="#（一）Namespace" class="headerlink" title="（一）Namespace"></a>（一）Namespace</h3><p>顾名思义，Namespace 就是命名空间。C++ 使用命名空间解决了类型、变量和函数的冲突问题。Docker 容器也具有自己的命名空间，通过命名空间对资源对象进行隔离，使得不同的容器进程号、用户、文件目录等相互屏蔽。Linux 支持的命名空间有以下几种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Namespace</th>
<th>Flag</th>
<th>Isolates</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>隔离文件系统挂载点</td>
</tr>
<tr>
<td>IPC</td>
<td>CLONE_NEWIPC</td>
<td>隔离进程间通信</td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>隔离网络</td>
</tr>
<tr>
<td>PID</td>
<td>CLONE_NEWPID</td>
<td>隔离进程 ID</td>
</tr>
<tr>
<td>USER</td>
<td>CLONE_NEWUSER</td>
<td>隔离用户和用户组</td>
</tr>
<tr>
<td>UTS</td>
<td>CLONE_NEWUTS</td>
<td>隔离主机名和域名</td>
</tr>
<tr>
<td>Time</td>
<td>CLONE_NEWTIME</td>
<td>隔离系统时间</td>
</tr>
</tbody>
</table>
</div>
<h3 id="（二）Cgroups"><a href="#（二）Cgroups" class="headerlink" title="（二）Cgroups"></a>（二）Cgroups</h3><p>Linux Cgroups 的全称是 Linux Control Group，主要用于对共享资源进行隔离、限制、审计。通过 Cgroups 限制容器能够使用的资源上限，包括 cpu、内存、磁盘、网络带宽等，可以避免多个容器之间的资源竞争。Linux 一切皆文件，Cgroups 也是通过树状的文件系统来对资源进行限制。</p>
<ul>
<li><p>查看 cgroup 挂载的目录，可以看到 cgroup 挂在 sys/fs/cgroup 节点，该路径下还有很多子目录（又称子系统），如 cpu、memory 等，每个子系统对应一种可以被限制的资源类型。</p>
<img src="/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/cgroup%E6%8C%82%E8%BD%BD.png" class title="cgroup 挂载 ">
</li>
<li><p>以 cpu 为例，查看 cpu 子系统。其中有两个参数 cfs_period_us 和 cfs_quota_us 通常组合使用，用于限制进程在长度为 cfs_period_us 的时间内，只能被分配到总量为 cfs_quota_us 的 cpu 时间。还有一个 tasks 文件，其中存放的是受限制的进程编号。</p>
<img src="/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/cpu%E5%AD%90%E7%B3%BB%E7%BB%9F.png" class title="cpu 子系统 ">
<img src="/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/cpu%E9%99%90%E5%88%B6.png" class title="cpu 限制 ">  
</li>
<li><p>cpu 子系统中有个 docker 子目录，docker 目录中的文件与 cpu 目录中的文件一样。当我们拉起一个容器，比如运行 redis 镜像，可以看到 docker 目录中又多了一层以容器 id 为名称的子目录。</p>
<img src="/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/docker%E5%AD%90%E7%9B%AE%E5%BD%95.png" class title="docker 子目录 ">
<img src="/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E5%AE%B9%E5%99%A8%E5%AD%90%E7%9B%AE%E5%BD%95.png" class title=" 容器子目录 ">  
</li>
</ul>
<p>综上两点，容器其实是一个启用了多种 Namespace 的进程，它能够使用的资源量收到 Cgroups 的限制。截至目前，我们使用 Namespace 和 Cgroups 为容器开辟了一个独立的运行环境，接下来我们再剖析一下容器里运行的镜像。</p>
<p>前面提到，容器镜像是一个文件系统，我们运行 ubuntu 的镜像，可以通过命令行查看根目录内容，也可以创建并执行脚本文件：</p>
<img src="/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/ubuntu%E5%AE%B9%E5%99%A8.png" class title="ubuntu 容器 ">
<p>我们还可以把改动之后的文件系统打包成我们自己的镜像，下次直接执行：</p>
<img src="/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/ubuntu%E5%AE%B9%E5%99%A8%E4%BF%AE%E6%94%B9.png" class title="ubuntu 容器修改 ">
<p>可以看到，我们以 ubuntu 文件系统为基础，加了一层我们自己的修改，打包了一个新的镜像。容器镜像实际上就是以 Linux 的联合文件系统机制（UnionFS）实现分层文件系统。</p>
<h3 id="（三）UnionFS"><a href="#（三）UnionFS" class="headerlink" title="（三）UnionFS"></a>（三）UnionFS</h3><p>UnionFS（联合文件系统），可以将不同目录挂载到同一个虚拟文件系统下。Docker 利用 UnionFS 的功能，在基础文件系统上以增量的方式，叠加一层又一层新的文件系统，通过联合挂载，最终得到一个完整的 Docker 镜像文件系统。</p>
<p>Docker 分层镜像的示例图如下，除了最顶层（称为容器层）是可写的，其他层（称为镜像层）都是只读的。UnoinFS 将所有层都叠加起来，形成最后我们在容器中所看到的文件系统。</p>
<img src="/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/docker%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82.png" class title="docker 镜像分层 ">
<p>由于镜像层都是只读的，所有对文件的修改操作都发生在容器层中，Docker 采用了 <strong>Copy-On-Write（写时复制）</strong> 的机制，具体来说：</p>
<ul>
<li>新增文件：在容器层中创建文件</li>
<li>读取文件：自上而下在各层中查找文件，一旦找到，打开并读入内存</li>
<li>修改文件：自上而下在各层中查找文件，找到后，将文件复制到容器层，在容器层中修改对应文件</li>
<li>删除文件：自上而下在各层中查找文件，找到后，在容器层中记录删除操作</li>
</ul>
<p>通过这种分层且只读的设计，使得每一个镜像层都是唯一且不变的，同一个镜像层可以在不同 docker 镜像中共享，只需要下载一次，存储一份，从而节省了大量的资源消耗和占用。</p>
<h3 id="（四）Volumes"><a href="#（四）Volumes" class="headerlink" title="（四）Volumes"></a>（四）Volumes</h3><p>由前所述，启动容器后，在容器内执行的所有文件的修改，都保存在容器层中，在删除容器时，对应的修改也会被删除。当我们需要保存修改的结果时，就需要用到数据卷（Data Volume），换句话说，数据卷提供了一种数据持久化的方式，使得在容器中产生的修改能永久的保留到宿主机上。数据卷的使用也很简单，在启动容器时，将宿主机的目录映射到容器中即可。</p>
<h2 id="三、使用方法"><a href="# 三、使用方法" class="headerlink" title="三、使用方法"></a>三、使用方法 </h2><h3 id="（一）命令行"><a href="#（一）命令行" class="headerlink" title="（一）命令行"></a>（一）命令行</h3><p> 与 Linux 一样，Docker 主要通过命令行操作，Docker 提供了非常多的命令，可以通过如下命令查看说明文档：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker command --help</span><br></pre></td></tr></table></figure>
<p>Docker 命令主要涉及到镜像、容器、仓库的操作和使用，下图可以概览全貌：</p>
<img src="/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/docker%E5%91%BD%E4%BB%A4.png" class title="Docker 命令 ">
<p>以下列举一些常用的 docker 命令，各命令详细用法可以通过 help 查看：</p>
<h4 id="1- 镜像相关"><a href="#1- 镜像相关" class="headerlink" title="1. 镜像相关"></a>1. 镜像相关</h4><ul>
<li><p>搜索镜像：search</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search python</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取镜像：pull，不指定标签时，默认拉取 lastest 版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull python</span><br></pre></td></tr></table></figure>
</li>
<li><p>推送镜像：push</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push python</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建镜像：build，根据 Dockerfile 构建镜像，Dockerfile 见下一节内容。以下这条命令是指在根据当前目录的 Dockerfile 文件，构建一个名为 my_python 的镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my_python .</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出镜像：images，等同于 image ls</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除镜像：rmi，等同于 image rm</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi python</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2- 容器相关"><a href="#2- 容器相关" class="headerlink" title="2. 容器相关"></a>2. 容器相关</h4><ul>
<li><p>运行容器：run，创建一个容器，运行镜像文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看容器：ps，默认只列出运行中的容器，加 -a 参数可以列出所有容器，显示结果中第一列为 CONTAINER ID，是容器的唯一标识</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动容器：start</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 369dde08ff20</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止容器：stop</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 369dde08ff20</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除容器：rm</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 369dde08ff20</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启容器：restart</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 369dde08ff20</span><br></pre></td></tr></table></figure>
</li>
<li><p>链接容器：attach，连接一个正在运行的容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 369dde08ff20</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行命令：exec，在正在运行的容器中执行命令。以下这条命令在 ID 为 369dde08ff20 的容器中，开启一个交互式命令行终端</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 369dde08ff20 /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看信息：inspect，查看镜像或容器的具体配置信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 369dde08ff20</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交镜像：commit，将当前容器的修改保存为镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m &quot;container to image&quot; 369dde08ff20 my_ubuntu</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看变更：diff，将容器创建以来，文件系统中发生变更的文件和目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff 369dde08ff20</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝文件：cp，用于在容器和宿主机之间拷贝数据。以下这条命令将容器中的 /tmp 目录，拷贝到宿主机中的 /tmp 目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 369dde08ff20:/tmp/ /tmp/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="（二）镜像制作"><a href="#（二）镜像制作" class="headerlink" title="（二）镜像制作"></a>（二）镜像制作 </h3><p> 制作 Docker 镜像有两种方法，一种是在容器中使用 commit 提交修改，另一种是使用 Dockfile 进行 build，后一种是主流做法。</p>
<p>Dockerfile 是由一行行指令组成的脚本文件，每一行命令都会生成一个镜像层，多行命令生成多个镜像层，叠加生成最终的镜像文件。Dockerfile 的常见指令及含义如图所示：</p>
<img src="/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/dockerfile%E5%91%BD%E4%BB%A4.jpg" class title="Dockerfile 指令 ">
<p>最后看个 Dockerfile 的小例子：</p>
<ol>
<li><p>编写 Dockerfile 文件</p>
<img src="/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E7%BC%96%E5%86%99dockerfile.png" class title=" 编写 dockerfile">
</li>
<li><p>生成镜像文件</p>
<img src="/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E7%94%9F%E6%88%90docker%E9%95%9C%E5%83%8F.png" class title=" 生成 docker 镜像 ">
</li>
<li><p>查看并运行镜像文件</p>
<img src="/2023/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E6%9F%A5%E7%9C%8B%E5%B9%B6%E8%BF%90%E8%A1%8Cdocker%E9%95%9C%E5%83%8F.png" class title=" 查看并运行 docker 镜像 ">
</li>
</ol>
<h2 id="四、参考资料"><a href="# 四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://blog.csdn.net/crazymakercircle/article/details/120747767">Docker 原理（图解 + 秒懂 + 史上最全）</a> </li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.docker.com/engine/reference/commandline/cli/">Docker 命令行官方手册</a> </li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cnblogs.com/panwenbin-logs/p/8007348.html">Dockerfile 文件详解</a></li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/Linux%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E7%BB%83/" title="Linux 从入门到熟练"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Linux 从入门到熟练</div></div><div class="info-2"><div class="info-item-1">Linux系统掌握需精通CLI命令操作、文件目录结构、权限管理（含特殊权限SUID/SGID）及网络配置（IP/DNS），涵盖文本编辑、进程控制、挂载操作等核心运维技能。</div></div></div></a><a class="pagination-related" href="/2023/LibFuzzer%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" title="LibFuzzer 使用说明"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">LibFuzzer 使用说明</div></div><div class="info-2"><div class="info-item-1">LibFuzzer作为LLVM进程内覆盖率引导模糊测试引擎，通过编写LLVMFuzzerTestOneInput函数、编译链接消毒器及执行参数控制，实现高效变异与语料优化，支持并行化测试。</div></div></div></a></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/photo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info-name">一瓢清浅</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/jiliguluss"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">个人技术博客，涉及软件开发、安全测试、AI算法等领域。不求精深，但当涉猎，有所闻耳。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">一、基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E9%95%9C%E5%83%8F%EF%BC%88Image%EF%BC%89"><span class="toc-text">（一）镜像（Image）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AE%B9%E5%99%A8%EF%BC%88Container%EF%BC%89"><span class="toc-text">（二）容器（Container）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E4%BB%93%E5%BA%93%EF%BC%88Repository%EF%BC%89"><span class="toc-text">（三）仓库（Repository）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86"><span class="toc-text">二、基础原理 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89Namespace"><span class="toc-text">（一）Namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89Cgroups"><span class="toc-text">（二）Cgroups</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89UnionFS"><span class="toc-text">（三）UnionFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89Volumes"><span class="toc-text">（四）Volumes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">三、使用方法 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="toc-text">（一）命令行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%20%E9%95%9C%E5%83%8F%E7%9B%B8%E5%85%B3"><span class="toc-text">1. 镜像相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%20%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="toc-text">2. 容器相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C"><span class="toc-text">（二）镜像制作 </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">四、参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/%E5%A4%9A%E8%87%82%E8%80%81%E8%99%8E%E6%9C%BA/" title="多臂老虎机">多臂老虎机</a><time datetime="2025-05-28T00:57:38.000Z" title="Created 2025-05-28 08:57:38">2025-05-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/" title="进程间通信机制">进程间通信机制</a><time datetime="2025-05-26T06:24:56.000Z" title="Created 2025-05-26 14:24:56">2025-05-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/Web%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/" title="Web 应用架构">Web 应用架构</a><time datetime="2025-05-21T06:52:47.000Z" title="Created 2025-05-21 14:52:47">2025-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/%E3%80%8A%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8%E3%80%81%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《股票投资入门、进阶与实战》笔记">《股票投资入门、进阶与实战》笔记</a><time datetime="2025-02-24T04:50:18.000Z" title="Created 2025-02-24 12:50:18">2025-02-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/%E3%80%8A%E6%8A%95%E8%B5%84%E4%B8%AD%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《投资中最简单的事》笔记">《投资中最简单的事》笔记</a><time datetime="2025-01-20T01:05:49.000Z" title="Created 2025-01-20 09:05:49">2025-01-20</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By 一瓢清浅</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23li8lUWNadcQIsjjS',
      clientSecret: '0dab34b0b46c7ccd1aa1e46ea1759edeef2beb67',
      repo: 'comment',
      owner: 'jiliguluss',
      admin: ['jiliguluss'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '6e720966489fdbeb17f8c0ce3b3e26fb'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>